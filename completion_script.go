package completionflags

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

// GenerateCompletionScript generates a bash completion script
func (cmd *Command) GenerateCompletionScript() string {
	// Get the actual binary name from os.Args[0]
	binaryName := filepath.Base(os.Args[0])

	return fmt.Sprintf(`# Bash completion for %s
# Generated by autocli
#
# This script uses a shared completion function (_autocli_complete)
# that works for all programs built with autocli.
# This allows bash to load the function once and reuse it for multiple programs.
#
# Features:
# - Process substitution support: completes inside <(...) for nested commands
# - JSON directive parsing for field caching and environment variables
# - Handles pipes inside process substitutions

# Define the shared completion function
_autocli_complete() {
    local cur prev words cword
    cur="${COMP_WORDS[COMP_CWORD]}"

    # Check if we're inside a process substitution <(...)
    local i in_procsub=0 procsub_start=0 paren_depth=0
    for ((i=0; i<COMP_CWORD; i++)); do
        local word="${COMP_WORDS[i]}"
        if [[ "$word" == "<(" || "$word" == ">(" ]]; then
            in_procsub=1
            procsub_start=$((i+1))
            paren_depth=1
        elif [[ "$word" == ")" || "$word" == *")" ]] && [[ $in_procsub -eq 1 ]]; then
            # Word is ")" or ends with ")" - closes process substitution
            paren_depth=$((paren_depth-1))
            if [[ $paren_depth -eq 0 ]]; then
                in_procsub=0
            fi
        elif [[ "$word" == *"("* && $in_procsub -eq 1 ]]; then
            # Nested parentheses - increment depth
            paren_depth=$((paren_depth+1))
        fi
    done

    if [[ $in_procsub -eq 1 && $procsub_start -le $COMP_CWORD ]]; then
        # We're inside <(...) - but there might be pipes inside
        # Find the last pipe to get the actual current command
        local last_pipe=$((procsub_start - 1))
        for ((i=procsub_start; i<COMP_CWORD; i++)); do
            if [[ "${COMP_WORDS[i]}" == "|" ]]; then
                last_pipe=$i
            fi
        done

        # The inner command starts after the last pipe (or at procsub_start if no pipe)
        local cmd_start=$((last_pipe + 1))
        local inner_cmd="${COMP_WORDS[cmd_start]}"
        local inner_cword=$((COMP_CWORD - cmd_start))

        # Build the completion command for the inner command
        local cmd=("$inner_cmd" -complete "$inner_cword")
        for ((i=cmd_start+1; i<=COMP_CWORD; i++)); do
            local arg="${COMP_WORDS[i]}"
            [[ -z "$arg" ]] && arg="''"
            cmd+=("$arg")
        done

        # Save outer context's cache variables before inner completion
        local saved_fields="${AUTOCLI_FIELDS:-}"
        local saved_file="${AUTOCLI_CACHE_FILE:-}"

        # Clear cache variables so inner command starts fresh
        # (otherwise it falls back to outer context's cached fields)
        unset AUTOCLI_FIELDS
        unset AUTOCLI_CACHE_FILE

        # Try to get completions from inner command
        local output
        output=$(eval "${cmd[@]}" 2>/dev/null)
        local rc=$?

        # If inner command doesn't support -complete (rc != 0 and no output),
        # fall back to default bash completion
        if [[ $rc -ne 0 && -z "$output" ]]; then
            COMPREPLY=( $(compgen -f -- "$cur") )
            # Restore outer context
            [[ -n "$saved_fields" ]] && export AUTOCLI_FIELDS="$saved_fields"
            [[ -n "$saved_file" ]] && export AUTOCLI_CACHE_FILE="$saved_file"
            return
        fi

        # Process output same as normal completion
        if [[ -n "$output" ]]; then
            _autocli_process_output "$output"
        fi

        # Restore outer context's cache variables after inner completion
        if [[ -n "$saved_fields" ]]; then
            export AUTOCLI_FIELDS="$saved_fields"
        fi
        if [[ -n "$saved_file" ]]; then
            export AUTOCLI_CACHE_FILE="$saved_file"
        fi
        return
    fi

    # Check if current word is "<(" - user just opened process substitution
    # Suggest the outer command as starting point
    if [[ "$cur" == "<(" ]]; then
        local outer_cmd="${COMP_WORDS[0]}"
        COMPREPLY=( "$outer_cmd" )
        return
    fi

    # Normal completion - call the binary with -complete
    # But first, collapse any process substitutions into placeholder file args
    local collapsed_args=()
    local collapsed_cword=$COMP_CWORD
    local skip_until_close=0
    local skipped=0

    for ((i=1; i<${#COMP_WORDS[@]}; i++)); do
        local word="${COMP_WORDS[i]}"

        if [[ $skip_until_close -eq 1 ]]; then
            # Inside a process substitution - skip this word
            skipped=$((skipped+1))
            if [[ "$word" == *")" ]]; then
                skip_until_close=0
            fi
            continue
        fi

        if [[ "$word" == "<(" || "$word" == ">(" ]]; then
            # Start of process substitution - replace with placeholder
            skip_until_close=1
            collapsed_args+=("/dev/fd/63")  # Placeholder for process substitution
            continue
        fi

        collapsed_args+=("$word")
    done

    # Adjust cword for skipped words
    collapsed_cword=$((COMP_CWORD - skipped))

    local output
    local cmd=("${COMP_WORDS[0]}" -complete "$collapsed_cword")
    for arg in "${collapsed_args[@]}"; do
        [[ -z "$arg" ]] && arg="''"
        cmd+=("$arg")
    done

    output=$(eval "${cmd[@]}" 2>/dev/null)

    if [[ -n "$output" ]]; then
        _autocli_process_output "$output"
    fi
}

# Helper function to process completion output (handles JSON directives)
_autocli_process_output() {
    local output="$1"
    local cur="${COMP_WORDS[COMP_CWORD]}"

    # Parse JSON directives if jq is available
    if command -v jq &>/dev/null; then
        local json_lines non_json_lines
        json_lines=$(echo "$output" | grep '^{.*}$')
        non_json_lines=$(echo "$output" | grep -v '^{.*}$')

        if [[ -n "$json_lines" ]]; then
            while IFS= read -r json_line; do
                local directive_type
                directive_type=$(echo "$json_line" | jq -r '.type // empty' 2>/dev/null)

                case "$directive_type" in
                    field_cache)
                        local fields filepath
                        fields=$(echo "$json_line" | jq -r '.fields[]? // empty' 2>/dev/null | paste -sd,)
                        filepath=$(echo "$json_line" | jq -r '.filepath // empty' 2>/dev/null)
                        [[ -n "$fields" ]] && export AUTOCLI_FIELDS="$fields"
                        [[ -n "$filepath" ]] && export AUTOCLI_CACHE_FILE="$filepath"
                        ;;
                    env)
                        local key value
                        key=$(echo "$json_line" | jq -r '.key // empty' 2>/dev/null)
                        value=$(echo "$json_line" | jq -r '.value // empty' 2>/dev/null)
                        [[ -n "$key" ]] && export "$key=$value"
                        ;;
                esac
            done <<< "$json_lines"
        fi

        output="$non_json_lines"
    fi

    if [[ -n "$output" ]]; then
        local IFS=$'\n'
        local completions=( $(compgen -W "$output" -- "$cur") )
        COMPREPLY=()
        for item in "${completions[@]}"; do
            COMPREPLY+=("$(printf "%%q" "$item")")
        done
    fi
}

# Register the completion function for this command
complete -F _autocli_complete %s
`, binaryName, binaryName)
}

// handleCompletion handles the -complete flag
// args: [position, arg1, arg2, ...]
func (cmd *Command) handleCompletion(args []string) error {
	if len(args) < 1 {
		return fmt.Errorf("completion requires position argument")
	}

	pos, err := strconv.Atoi(args[0])
	if err != nil {
		return fmt.Errorf("invalid position: %s", args[0])
	}

	// Rest are the command arguments
	compArgs := []string{}
	if len(args) > 1 {
		compArgs = args[1:]
	}

	// Get completions
	completions, err := cmd.complete(compArgs, pos)
	if err != nil {
		return err
	}

	// Output one per line
	for _, completion := range completions {
		fmt.Println(completion)
	}

	return nil
}

// complete generates completions for a given position
func (cmd *Command) complete(args []string, pos int) ([]string, error) {
	// Check if we have subcommands
	if len(cmd.subcommands) > 0 {
		return cmd.completeWithSubcommands(args, pos)
	}

	// No subcommands - use standard completion
	ctx := cmd.analyzeCompletionContext(args, pos)
	return cmd.executeCompletion(ctx)
}

// analyzeCompletionContext analyzes command line to determine what to complete
func (cmd *Command) analyzeCompletionContext(args []string, pos int) CompletionContext {
	ctx := CompletionContext{
		Args:          args,
		Position:      pos,
		Command:       cmd,
		ParsedClauses: []Clause{},
		GlobalFlags:   make(map[string]interface{}),
	}

	// Get current word being completed
	// pos is the index in COMP_WORDS (includes command at index 0)
	// args is COMP_WORDS[1:] (excludes command)
	// So the word at pos in COMP_WORDS is at pos-1 in args
	argIndex := pos - 1
	if argIndex >= 0 && argIndex < len(args) {
		ctx.Partial = args[argIndex]
	} else {
		ctx.Partial = ""
	}

	// Adjust pos for the rest of the analysis to work with args indices
	pos = argIndex

	// If completing a flag name
	if strings.HasPrefix(ctx.Partial, "-") || strings.HasPrefix(ctx.Partial, "+") {
		// Complete flag names
		return ctx
	}

	// Parse as much as we can to build context
	// Clamp pos to valid range to avoid panic
	parseUpTo := pos
	if parseUpTo < 0 {
		parseUpTo = 0
	}
	if parseUpTo > len(args) {
		parseUpTo = len(args)
	}
	partialCtx, _ := cmd.Parse(args[:parseUpTo])
	if partialCtx != nil {
		ctx.ParsedClauses = partialCtx.Clauses
		ctx.GlobalFlags = partialCtx.GlobalFlags
		if len(partialCtx.Clauses) > 0 {
			ctx.CurrentClause = &partialCtx.Clauses[len(partialCtx.Clauses)-1]
		}
	}

	// Find the flag we're completing an argument for
	// When pos >= len(args), we need to look at the last actual arg
	searchPos := pos
	if searchPos > len(args) {
		searchPos = len(args)
	}

	flagPos, spec := cmd.findLastFlag(args, searchPos)
	if spec != nil {
		ctx.FlagName = spec.Names[0]

		// Calculate which argument of the flag we're completing
		// If pos >= len(args), we're completing after all existing args
		// The partial is at position pos-1 in that case (or doesn't exist yet)
		actualPos := pos
		if pos >= len(args) && pos > 0 {
			actualPos = pos - 1
		}
		ctx.ArgIndex = actualPos - flagPos - 1

		// Collect previous arguments of this flag
		if ctx.ArgIndex > 0 && flagPos+1 < len(args) {
			endPos := pos
			if endPos > len(args) {
				endPos = len(args)
			}
			ctx.PreviousArgs = args[flagPos+1 : endPos]
		}
	}

	return ctx
}

// findLastFlag finds the most recent flag before the current position
func (cmd *Command) findLastFlag(args []string, pos int) (int, *FlagSpec) {
	for i := pos - 1; i >= 0; i-- {
		if i >= len(args) {
			continue
		}

		arg := args[i]

		// Check if this is a separator
		if cmd.isSeparator(arg) {
			// Don't go past clause boundaries
			return -1, nil
		}

		// Check if this is a flag
		if strings.HasPrefix(arg, "-") || strings.HasPrefix(arg, "+") {
			// Normalize to find spec
			normalized := arg
			if strings.HasPrefix(arg, "+") {
				normalized = "-" + arg[1:]
			}

			spec := cmd.findFlagSpec(normalized)
			if spec != nil {
				return i, spec
			}
		}
	}

	return -1, nil
}

// executeCompletion executes the appropriate completion based on context
func (cmd *Command) executeCompletion(ctx CompletionContext) ([]string, error) {
	// Case 1: Completing a flag name
	if strings.HasPrefix(ctx.Partial, "-") || strings.HasPrefix(ctx.Partial, "+") {
		return cmd.completeFlags(ctx.Partial), nil
	}

	// Case 2: Completing a flag argument
	if ctx.FlagName != "" {
		spec := cmd.findFlagSpec(ctx.FlagName)
		if spec != nil && ctx.ArgIndex >= 0 && ctx.ArgIndex < len(spec.ArgCompleters) {
			completer := spec.ArgCompleters[ctx.ArgIndex]
			return completer.Complete(ctx)
		}
		// If ArgIndex is out of bounds for this flag, fall through
	}

	// Case 3: Completing a positional argument
	positionalCompletion, err := cmd.completePositional(ctx)
	if err != nil {
		return []string{}, err
	}
	if len(positionalCompletion) > 0 {
		return positionalCompletion, nil
	}

	// Case 4: Empty partial - show all flags
	// This handles both "no flag context" and "flag arguments exhausted"
	if ctx.Partial == "" {
		return cmd.completeFlags(""), nil
	}

	// Case 5: Default to no completions
	return []string{}, nil
}

// completeFlags generates flag name completions
func (cmd *Command) completeFlags(partial string) []string {
	var matches []string
	partialLower := strings.ToLower(partial)

	for _, spec := range cmd.flags {
		if spec.Hidden {
			continue
		}

		for _, name := range spec.Names {
			// Add -flag version
			nameLower := strings.ToLower(name)
			if partialLower == "" || partialLower == "-" || partialLower == "+" || strings.HasPrefix(nameLower, partialLower) {
				matches = append(matches, name)
			}

			// Add +flag version (convert -flag to +flag)
			if strings.HasPrefix(name, "-") {
				plusVersion := "+" + name[1:]
				plusLower := strings.ToLower(plusVersion)
				if partialLower == "+" || strings.HasPrefix(plusLower, partialLower) {
					matches = append(matches, plusVersion)
				}
			}
		}
	}

	// Add built-in flags
	builtins := []string{"-help", "--help", "-h", "-man", "-completion-script"}
	for _, builtin := range builtins {
		if partialLower == "" || partialLower == "-" || strings.HasPrefix(builtin, partialLower) {
			matches = append(matches, builtin)
		}
	}

	return matches
}

// completePositional generates completions for positional arguments
func (cmd *Command) completePositional(ctx CompletionContext) ([]string, error) {
	positionals := cmd.positionalFlags()
	if len(positionals) == 0 {
		return []string{}, nil
	}

	// Count how many positional arguments are before the current position
	// We need to count non-flag, non-separator arguments in ctx.Args up to ctx.Position
	positionalCount := 0
	argIndex := ctx.Position - 1 // Convert from COMP_WORDS position to args index

	for i := 0; i < argIndex && i < len(ctx.Args); i++ {
		arg := ctx.Args[i]
		// Skip flags and separators
		if strings.HasPrefix(arg, "-") || strings.HasPrefix(arg, "+") || cmd.isSeparator(arg) {
			// Check if this is a flag that takes arguments
			if strings.HasPrefix(arg, "-") || strings.HasPrefix(arg, "+") {
				spec := cmd.findFlagSpec(arg)
				if spec != nil {
					// Skip this flag's arguments
					i += spec.ArgCount
				}
			}
			continue
		}
		// This is a positional argument
		positionalCount++
	}

	// Find the target positional spec based on count
	var targetSpec *FlagSpec

	// Check if the last positional is variadic
	if len(positionals) > 0 {
		lastSpec := positionals[len(positionals)-1]
		if lastSpec.IsVariadic && positionalCount >= len(positionals)-1 {
			// Use variadic for all remaining positions
			targetSpec = lastSpec
		}
	}

	// If not variadic or before variadic position, use the exact positional
	if targetSpec == nil && positionalCount < len(positionals) {
		targetSpec = positionals[positionalCount]
	}

	// If we found a target spec with a completer, use it
	if targetSpec != nil && len(targetSpec.ArgCompleters) > 0 {
		completer := targetSpec.ArgCompleters[0]
		return completer.Complete(ctx)
	}

	return []string{}, nil
}

// completeWithSubcommands handles completion for commands with subcommands
func (cmd *Command) completeWithSubcommands(args []string, pos int) ([]string, error) {
	// Parse root global flags to find where they end
	rootGlobals, remaining, err := cmd.parseRootGlobalFlags(args)
	if err != nil {
		// If parsing fails, still try to provide useful completions
		remaining = args
	}

	// Calculate the position within remaining args
	// We need to figure out how many args were consumed by root globals
	consumed := len(args) - len(remaining)
	remainingPos := pos - consumed - 1 // -1 for command itself (pos is in COMP_WORDS)

	// Case 1: We're still completing root global flags or the subcommand name
	if remainingPos < 0 || len(remaining) == 0 || (remainingPos == 0 && len(remaining) == 1) {
		// Get current partial
		argIndex := pos - 1
		partial := ""
		if argIndex >= 0 && argIndex < len(args) {
			partial = args[argIndex]
		}

		// If completing a flag, show root global flags
		if strings.HasPrefix(partial, "-") || strings.HasPrefix(partial, "+") {
			return cmd.completeRootGlobalFlags(partial), nil
		}

		// Otherwise, complete subcommand names
		return cmd.completeSubcommandNames(partial), nil
	}

	// Case 2: Walk the subcommand tree to find where we are
	if len(remaining) > 0 {
		path := []string{}
		currentSubcommands := cmd.subcommands
		var leafSubcmd *Subcommand
		argIndex := 0

		// Walk the tree as far as we have confirmed subcommands
		for argIndex < len(remaining) && argIndex < remainingPos {
			subcommandName := remaining[argIndex]
			subcmd := currentSubcommands[subcommandName]

			if subcmd == nil {
				// Not a subcommand - stop walking
				break
			}

			// Confirmed subcommand
			path = append(path, subcommandName)
			leafSubcmd = subcmd
			argIndex++

			// Move to nested subcommands if available
			if subcmd.Subcommands != nil {
				currentSubcommands = subcmd.Subcommands
			} else {
				// No more nested - this is the leaf
				break
			}
		}

		// Determine what we're completing
		partial := ""
		if pos-1 >= 0 && pos-1 < len(args) {
			partial = args[pos-1]
		}

		// If we're at a position where we could be completing a nested subcommand name
		if argIndex == remainingPos && leafSubcmd != nil && len(leafSubcmd.Subcommands) > 0 {
			// Check if completing a flag or a nested subcommand
			if strings.HasPrefix(partial, "-") || strings.HasPrefix(partial, "+") {
				// Complete flags for this level (root globals + current subcommand flags)
				tempCmd := &Command{
					name:       leafSubcmd.Name,
					flags:      append(cmd.rootGlobalFlags(), leafSubcmd.Flags...),
					separators: leafSubcmd.Separators,
				}
				return tempCmd.completeFlagNames(partial), nil
			}

			// Complete nested subcommand names
			return cmd.completeNestedSubcommandNames(leafSubcmd.Subcommands, partial), nil
		}

		// We have a leaf subcommand, complete its arguments
		if leafSubcmd != nil {
			// Create a temporary command for the leaf subcommand
			tempCmd := &Command{
				name:       leafSubcmd.Name,
				flags:      append(cmd.rootGlobalFlags(), leafSubcmd.Flags...),
				separators: leafSubcmd.Separators,
			}

			// Complete using subcommand context (remaining args after subcommand path)
			subcommandArgs := remaining[argIndex:]
			// subcommandPos needs +1 because analyzeCompletionContext expects COMP_WORDS-style
			// indexing where position 0 is the command name (in this case, the subcommand name)
			subcommandPos := remainingPos - argIndex + 1

			ctx := tempCmd.analyzeCompletionContext(subcommandArgs, subcommandPos)
			// Merge in already-parsed root globals
			for k, v := range rootGlobals {
				ctx.GlobalFlags[k] = v
			}

			return tempCmd.executeCompletion(ctx)
		}

		// Unknown subcommand at current level - show available subcommand names
		return cmd.completeNestedSubcommandNames(currentSubcommands, partial), nil
	}

	return []string{}, nil
}

// completeRootGlobalFlags generates completions for root global flags only
func (cmd *Command) completeRootGlobalFlags(partial string) []string {
	var matches []string
	partialLower := strings.ToLower(partial)

	for _, spec := range cmd.flags {
		if spec.Scope != ScopeGlobal || spec.Hidden {
			continue
		}

		for _, name := range spec.Names {
			nameLower := strings.ToLower(name)
			if partialLower == "" || partialLower == "-" || partialLower == "+" || strings.HasPrefix(nameLower, partialLower) {
				matches = append(matches, name)
			}

			// Add +flag version
			if strings.HasPrefix(name, "-") {
				plusVersion := "+" + name[1:]
				plusLower := strings.ToLower(plusVersion)
				if partialLower == "+" || strings.HasPrefix(plusLower, partialLower) {
					matches = append(matches, plusVersion)
				}
			}
		}
	}

	return matches
}

// completeSubcommandNames generates completions for subcommand names
func (cmd *Command) completeSubcommandNames(partial string) []string {
	var matches []string
	partialLower := strings.ToLower(partial)

	for name := range cmd.subcommands {
		nameLower := strings.ToLower(name)
		if partialLower == "" || strings.HasPrefix(nameLower, partialLower) {
			matches = append(matches, name)
		}
	}

	return matches
}

// completeNestedSubcommandNames generates completions for nested subcommand names
func (cmd *Command) completeNestedSubcommandNames(subcommands map[string]*Subcommand, partial string) []string {
	var matches []string
	partialLower := strings.ToLower(partial)

	for name := range subcommands {
		nameLower := strings.ToLower(name)
		if partialLower == "" || strings.HasPrefix(nameLower, partialLower) {
			matches = append(matches, name)
		}
	}

	return matches
}

// completeFlagNames generates completions for flag names (used by temporary commands)
func (cmd *Command) completeFlagNames(partial string) []string {
	var matches []string
	partialLower := strings.ToLower(partial)

	for _, spec := range cmd.flags {
		if spec.Hidden {
			continue
		}

		for _, name := range spec.Names {
			// Add -flag version
			nameLower := strings.ToLower(name)
			if partialLower == "" || partialLower == "-" || partialLower == "+" || strings.HasPrefix(nameLower, partialLower) {
				matches = append(matches, name)
			}

			// Add +flag version (convert -flag to +flag)
			if strings.HasPrefix(name, "-") {
				plusVersion := "+" + name[1:]
				plusLower := strings.ToLower(plusVersion)
				if partialLower == "+" || strings.HasPrefix(plusLower, partialLower) {
					matches = append(matches, plusVersion)
				}
			}
		}
	}

	// Add built-in flags
	builtins := []string{"-help", "--help", "-h", "-man", "-completion-script"}
	for _, builtin := range builtins {
		if partialLower == "" || partialLower == "-" || strings.HasPrefix(builtin, partialLower) {
			matches = append(matches, builtin)
		}
	}

	return matches
}
