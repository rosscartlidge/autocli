package completionflags

import (
	"fmt"
	"strconv"
	"strings"
)

// GenerateCompletionScript generates a bash completion script
func (cmd *Command) GenerateCompletionScript() string {
	return fmt.Sprintf(`# Bash completion for %s
# Generated by completionflags

_%s_complete() {
    local cur prev words cword
    cur="${COMP_WORDS[COMP_CWORD]}"

    # Call the binary with -complete to get completions
    # The binary handles all completion logic internally
    local completions
    completions=$(${COMP_WORDS[0]} -complete $COMP_CWORD "${COMP_WORDS[@]:1}" 2>/dev/null)

    if [[ -n "$completions" ]]; then
        COMPREPLY=($(compgen -W "$completions" -- "$cur"))
    fi
}

# Register the completion function
complete -F _%s_complete %s
`, cmd.name, sanitizeFunctionName(cmd.name), sanitizeFunctionName(cmd.name), cmd.name)
}

// sanitizeFunctionName converts a command name to a valid bash function name
func sanitizeFunctionName(name string) string {
	// Replace invalid characters with underscores
	result := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_' {
			return r
		}
		return '_'
	}, name)
	return result
}

// handleCompletion handles the -complete flag
// args: [position, arg1, arg2, ...]
func (cmd *Command) handleCompletion(args []string) error {
	if len(args) < 1 {
		return fmt.Errorf("completion requires position argument")
	}

	pos, err := strconv.Atoi(args[0])
	if err != nil {
		return fmt.Errorf("invalid position: %s", args[0])
	}

	// Rest are the command arguments
	compArgs := []string{}
	if len(args) > 1 {
		compArgs = args[1:]
	}

	// Get completions
	completions, err := cmd.complete(compArgs, pos)
	if err != nil {
		return err
	}

	// Output one per line
	for _, completion := range completions {
		fmt.Println(completion)
	}

	return nil
}

// complete generates completions for a given position
func (cmd *Command) complete(args []string, pos int) ([]string, error) {
	ctx := cmd.analyzeCompletionContext(args, pos)
	return cmd.executeCompletion(ctx)
}

// analyzeCompletionContext analyzes command line to determine what to complete
func (cmd *Command) analyzeCompletionContext(args []string, pos int) CompletionContext {
	ctx := CompletionContext{
		Args:          args,
		Position:      pos,
		Command:       cmd,
		ParsedClauses: []Clause{},
		GlobalFlags:   make(map[string]interface{}),
	}

	// Get current word being completed
	// pos is the index in COMP_WORDS (includes command at index 0)
	// args is COMP_WORDS[1:] (excludes command)
	// So the word at pos in COMP_WORDS is at pos-1 in args
	argIndex := pos - 1
	if argIndex >= 0 && argIndex < len(args) {
		ctx.Partial = args[argIndex]
	} else {
		ctx.Partial = ""
	}

	// Adjust pos for the rest of the analysis to work with args indices
	pos = argIndex

	// If completing a flag name
	if strings.HasPrefix(ctx.Partial, "-") || strings.HasPrefix(ctx.Partial, "+") {
		// Complete flag names
		return ctx
	}

	// Parse as much as we can to build context
	// Clamp pos to valid range to avoid panic
	parseUpTo := pos
	if parseUpTo < 0 {
		parseUpTo = 0
	}
	if parseUpTo > len(args) {
		parseUpTo = len(args)
	}
	partialCtx, _ := cmd.Parse(args[:parseUpTo])
	if partialCtx != nil {
		ctx.ParsedClauses = partialCtx.Clauses
		ctx.GlobalFlags = partialCtx.GlobalFlags
		if len(partialCtx.Clauses) > 0 {
			ctx.CurrentClause = &partialCtx.Clauses[len(partialCtx.Clauses)-1]
		}
	}

	// Find the flag we're completing an argument for
	// When pos >= len(args), we need to look at the last actual arg
	searchPos := pos
	if searchPos > len(args) {
		searchPos = len(args)
	}

	flagPos, spec := cmd.findLastFlag(args, searchPos)
	if spec != nil {
		ctx.FlagName = spec.Names[0]

		// Calculate which argument of the flag we're completing
		// If pos >= len(args), we're completing after all existing args
		// The partial is at position pos-1 in that case (or doesn't exist yet)
		actualPos := pos
		if pos >= len(args) && pos > 0 {
			actualPos = pos - 1
		}
		ctx.ArgIndex = actualPos - flagPos - 1

		// Collect previous arguments of this flag
		if ctx.ArgIndex > 0 && flagPos+1 < len(args) {
			endPos := pos
			if endPos > len(args) {
				endPos = len(args)
			}
			ctx.PreviousArgs = args[flagPos+1 : endPos]
		}
	}

	return ctx
}

// findLastFlag finds the most recent flag before the current position
func (cmd *Command) findLastFlag(args []string, pos int) (int, *FlagSpec) {
	for i := pos - 1; i >= 0; i-- {
		if i >= len(args) {
			continue
		}

		arg := args[i]

		// Check if this is a separator
		if cmd.isSeparator(arg) {
			// Don't go past clause boundaries
			return -1, nil
		}

		// Check if this is a flag
		if strings.HasPrefix(arg, "-") || strings.HasPrefix(arg, "+") {
			// Normalize to find spec
			normalized := arg
			if strings.HasPrefix(arg, "+") {
				normalized = "-" + arg[1:]
			}

			spec := cmd.findFlagSpec(normalized)
			if spec != nil {
				return i, spec
			}
		}
	}

	return -1, nil
}

// executeCompletion executes the appropriate completion based on context
func (cmd *Command) executeCompletion(ctx CompletionContext) ([]string, error) {
	// Case 1: Completing a flag name
	if strings.HasPrefix(ctx.Partial, "-") || strings.HasPrefix(ctx.Partial, "+") {
		return cmd.completeFlags(ctx.Partial), nil
	}

	// Case 2: Completing a flag argument
	if ctx.FlagName != "" {
		spec := cmd.findFlagSpec(ctx.FlagName)
		if spec != nil && ctx.ArgIndex >= 0 && ctx.ArgIndex < len(spec.ArgCompleters) {
			completer := spec.ArgCompleters[ctx.ArgIndex]
			return completer.Complete(ctx)
		}
		// If ArgIndex is out of bounds for this flag, fall through to show flags
	}

	// Case 3: Empty partial - show all flags
	// This handles both "no flag context" and "flag arguments exhausted"
	if ctx.Partial == "" {
		return cmd.completeFlags(""), nil
	}

	// Case 4: Default to no completions
	return []string{}, nil
}

// completeFlags generates flag name completions
func (cmd *Command) completeFlags(partial string) []string {
	var matches []string
	partialLower := strings.ToLower(partial)

	for _, spec := range cmd.flags {
		if spec.Hidden {
			continue
		}

		for _, name := range spec.Names {
			// Add -flag version
			nameLower := strings.ToLower(name)
			if partialLower == "" || partialLower == "-" || partialLower == "+" || strings.HasPrefix(nameLower, partialLower) {
				matches = append(matches, name)
			}

			// Add +flag version (convert -flag to +flag)
			if strings.HasPrefix(name, "-") {
				plusVersion := "+" + name[1:]
				plusLower := strings.ToLower(plusVersion)
				if partialLower == "+" || strings.HasPrefix(plusLower, partialLower) {
					matches = append(matches, plusVersion)
				}
			}
		}
	}

	// Add built-in flags
	builtins := []string{"-help", "--help", "-h", "-man", "-completion-script"}
	for _, builtin := range builtins {
		if partialLower == "" || partialLower == "-" || strings.HasPrefix(builtin, partialLower) {
			matches = append(matches, builtin)
		}
	}

	return matches
}
