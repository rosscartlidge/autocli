package completionflags

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

// GenerateCompletionScript generates a bash completion script
func (cmd *Command) GenerateCompletionScript() string {
	// Get the actual binary name from os.Args[0]
	binaryName := filepath.Base(os.Args[0])

	return fmt.Sprintf(`# Bash completion for %s
# Generated by autocli
#
# This script uses a shared completion function (_autocli_complete)
# that works for all programs built with autocli.
# This allows bash to load the function once and reuse it for multiple programs.

# Define the shared completion function if not already defined
if ! type _autocli_complete &>/dev/null; then
    _autocli_complete() {
        local cur prev words cword
        cur="${COMP_WORDS[COMP_CWORD]}"

        # Call the binary with -complete to get completions
        # The binary handles all completion logic internally
        local completions
        completions=$(${COMP_WORDS[0]} -complete $COMP_CWORD "${COMP_WORDS[@]:1}" 2>/dev/null)

        if [[ -n "$completions" ]]; then
            COMPREPLY=($(compgen -W "$completions" -- "$cur"))
        fi
    }
fi

# Register the completion function for this command
complete -F _autocli_complete %s
`, binaryName, binaryName)
}

// handleCompletion handles the -complete flag
// args: [position, arg1, arg2, ...]
func (cmd *Command) handleCompletion(args []string) error {
	if len(args) < 1 {
		return fmt.Errorf("completion requires position argument")
	}

	pos, err := strconv.Atoi(args[0])
	if err != nil {
		return fmt.Errorf("invalid position: %s", args[0])
	}

	// Rest are the command arguments
	compArgs := []string{}
	if len(args) > 1 {
		compArgs = args[1:]
	}

	// Get completions
	completions, err := cmd.complete(compArgs, pos)
	if err != nil {
		return err
	}

	// Output one per line
	for _, completion := range completions {
		fmt.Println(completion)
	}

	return nil
}

// complete generates completions for a given position
func (cmd *Command) complete(args []string, pos int) ([]string, error) {
	// Check if we have subcommands
	if len(cmd.subcommands) > 0 {
		return cmd.completeWithSubcommands(args, pos)
	}

	// No subcommands - use standard completion
	ctx := cmd.analyzeCompletionContext(args, pos)
	return cmd.executeCompletion(ctx)
}

// analyzeCompletionContext analyzes command line to determine what to complete
func (cmd *Command) analyzeCompletionContext(args []string, pos int) CompletionContext {
	ctx := CompletionContext{
		Args:          args,
		Position:      pos,
		Command:       cmd,
		ParsedClauses: []Clause{},
		GlobalFlags:   make(map[string]interface{}),
	}

	// Get current word being completed
	// pos is the index in COMP_WORDS (includes command at index 0)
	// args is COMP_WORDS[1:] (excludes command)
	// So the word at pos in COMP_WORDS is at pos-1 in args
	argIndex := pos - 1
	if argIndex >= 0 && argIndex < len(args) {
		ctx.Partial = args[argIndex]
	} else {
		ctx.Partial = ""
	}

	// Adjust pos for the rest of the analysis to work with args indices
	pos = argIndex

	// If completing a flag name
	if strings.HasPrefix(ctx.Partial, "-") || strings.HasPrefix(ctx.Partial, "+") {
		// Complete flag names
		return ctx
	}

	// Parse as much as we can to build context
	// Clamp pos to valid range to avoid panic
	parseUpTo := pos
	if parseUpTo < 0 {
		parseUpTo = 0
	}
	if parseUpTo > len(args) {
		parseUpTo = len(args)
	}
	partialCtx, _ := cmd.Parse(args[:parseUpTo])
	if partialCtx != nil {
		ctx.ParsedClauses = partialCtx.Clauses
		ctx.GlobalFlags = partialCtx.GlobalFlags
		if len(partialCtx.Clauses) > 0 {
			ctx.CurrentClause = &partialCtx.Clauses[len(partialCtx.Clauses)-1]
		}
	}

	// Find the flag we're completing an argument for
	// When pos >= len(args), we need to look at the last actual arg
	searchPos := pos
	if searchPos > len(args) {
		searchPos = len(args)
	}

	flagPos, spec := cmd.findLastFlag(args, searchPos)
	if spec != nil {
		ctx.FlagName = spec.Names[0]

		// Calculate which argument of the flag we're completing
		// If pos >= len(args), we're completing after all existing args
		// The partial is at position pos-1 in that case (or doesn't exist yet)
		actualPos := pos
		if pos >= len(args) && pos > 0 {
			actualPos = pos - 1
		}
		ctx.ArgIndex = actualPos - flagPos - 1

		// Collect previous arguments of this flag
		if ctx.ArgIndex > 0 && flagPos+1 < len(args) {
			endPos := pos
			if endPos > len(args) {
				endPos = len(args)
			}
			ctx.PreviousArgs = args[flagPos+1 : endPos]
		}
	}

	return ctx
}

// findLastFlag finds the most recent flag before the current position
func (cmd *Command) findLastFlag(args []string, pos int) (int, *FlagSpec) {
	for i := pos - 1; i >= 0; i-- {
		if i >= len(args) {
			continue
		}

		arg := args[i]

		// Check if this is a separator
		if cmd.isSeparator(arg) {
			// Don't go past clause boundaries
			return -1, nil
		}

		// Check if this is a flag
		if strings.HasPrefix(arg, "-") || strings.HasPrefix(arg, "+") {
			// Normalize to find spec
			normalized := arg
			if strings.HasPrefix(arg, "+") {
				normalized = "-" + arg[1:]
			}

			spec := cmd.findFlagSpec(normalized)
			if spec != nil {
				return i, spec
			}
		}
	}

	return -1, nil
}

// executeCompletion executes the appropriate completion based on context
func (cmd *Command) executeCompletion(ctx CompletionContext) ([]string, error) {
	// Case 1: Completing a flag name
	if strings.HasPrefix(ctx.Partial, "-") || strings.HasPrefix(ctx.Partial, "+") {
		return cmd.completeFlags(ctx.Partial), nil
	}

	// Case 2: Completing a flag argument
	if ctx.FlagName != "" {
		spec := cmd.findFlagSpec(ctx.FlagName)
		if spec != nil && ctx.ArgIndex >= 0 && ctx.ArgIndex < len(spec.ArgCompleters) {
			completer := spec.ArgCompleters[ctx.ArgIndex]
			return completer.Complete(ctx)
		}
		// If ArgIndex is out of bounds for this flag, fall through
	}

	// Case 3: Completing a positional argument
	positionalCompletion, err := cmd.completePositional(ctx)
	if err != nil {
		return []string{}, err
	}
	if len(positionalCompletion) > 0 {
		return positionalCompletion, nil
	}

	// Case 4: Empty partial - show all flags
	// This handles both "no flag context" and "flag arguments exhausted"
	if ctx.Partial == "" {
		return cmd.completeFlags(""), nil
	}

	// Case 5: Default to no completions
	return []string{}, nil
}

// completeFlags generates flag name completions
func (cmd *Command) completeFlags(partial string) []string {
	var matches []string
	partialLower := strings.ToLower(partial)

	for _, spec := range cmd.flags {
		if spec.Hidden {
			continue
		}

		for _, name := range spec.Names {
			// Add -flag version
			nameLower := strings.ToLower(name)
			if partialLower == "" || partialLower == "-" || partialLower == "+" || strings.HasPrefix(nameLower, partialLower) {
				matches = append(matches, name)
			}

			// Add +flag version (convert -flag to +flag)
			if strings.HasPrefix(name, "-") {
				plusVersion := "+" + name[1:]
				plusLower := strings.ToLower(plusVersion)
				if partialLower == "+" || strings.HasPrefix(plusLower, partialLower) {
					matches = append(matches, plusVersion)
				}
			}
		}
	}

	// Add built-in flags
	builtins := []string{"-help", "--help", "-h", "-man", "-completion-script"}
	for _, builtin := range builtins {
		if partialLower == "" || partialLower == "-" || strings.HasPrefix(builtin, partialLower) {
			matches = append(matches, builtin)
		}
	}

	return matches
}

// completePositional generates completions for positional arguments
func (cmd *Command) completePositional(ctx CompletionContext) ([]string, error) {
	positionals := cmd.positionalFlags()
	if len(positionals) == 0 {
		return []string{}, nil
	}

	// Count how many positional arguments are before the current position
	// We need to count non-flag, non-separator arguments in ctx.Args up to ctx.Position
	positionalCount := 0
	argIndex := ctx.Position - 1 // Convert from COMP_WORDS position to args index

	for i := 0; i < argIndex && i < len(ctx.Args); i++ {
		arg := ctx.Args[i]
		// Skip flags and separators
		if strings.HasPrefix(arg, "-") || strings.HasPrefix(arg, "+") || cmd.isSeparator(arg) {
			// Check if this is a flag that takes arguments
			if strings.HasPrefix(arg, "-") || strings.HasPrefix(arg, "+") {
				spec := cmd.findFlagSpec(arg)
				if spec != nil {
					// Skip this flag's arguments
					i += spec.ArgCount
				}
			}
			continue
		}
		// This is a positional argument
		positionalCount++
	}

	// Find the target positional spec based on count
	var targetSpec *FlagSpec

	// Check if the last positional is variadic
	if len(positionals) > 0 {
		lastSpec := positionals[len(positionals)-1]
		if lastSpec.IsVariadic && positionalCount >= len(positionals)-1 {
			// Use variadic for all remaining positions
			targetSpec = lastSpec
		}
	}

	// If not variadic or before variadic position, use the exact positional
	if targetSpec == nil && positionalCount < len(positionals) {
		targetSpec = positionals[positionalCount]
	}

	// If we found a target spec with a completer, use it
	if targetSpec != nil && len(targetSpec.ArgCompleters) > 0 {
		completer := targetSpec.ArgCompleters[0]
		return completer.Complete(ctx)
	}

	return []string{}, nil
}

// completeWithSubcommands handles completion for commands with subcommands
func (cmd *Command) completeWithSubcommands(args []string, pos int) ([]string, error) {
	// Parse root global flags to find where they end
	rootGlobals, remaining, err := cmd.parseRootGlobalFlags(args)
	if err != nil {
		// If parsing fails, still try to provide useful completions
		remaining = args
	}

	// Calculate the position within remaining args
	// We need to figure out how many args were consumed by root globals
	consumed := len(args) - len(remaining)
	remainingPos := pos - consumed - 1 // -1 for command itself (pos is in COMP_WORDS)

	// Case 1: We're still completing root global flags or the subcommand name
	if remainingPos < 0 || len(remaining) == 0 || (remainingPos == 0 && len(remaining) == 1) {
		// Get current partial
		argIndex := pos - 1
		partial := ""
		if argIndex >= 0 && argIndex < len(args) {
			partial = args[argIndex]
		}

		// If completing a flag, show root global flags
		if strings.HasPrefix(partial, "-") || strings.HasPrefix(partial, "+") {
			return cmd.completeRootGlobalFlags(partial), nil
		}

		// Otherwise, complete subcommand names
		return cmd.completeSubcommandNames(partial), nil
	}

	// Case 2: Walk the subcommand tree to find where we are
	if len(remaining) > 0 {
		path := []string{}
		currentSubcommands := cmd.subcommands
		var leafSubcmd *Subcommand
		argIndex := 0

		// Walk the tree as far as we have confirmed subcommands
		for argIndex < len(remaining) && argIndex < remainingPos {
			subcommandName := remaining[argIndex]
			subcmd := currentSubcommands[subcommandName]

			if subcmd == nil {
				// Not a subcommand - stop walking
				break
			}

			// Confirmed subcommand
			path = append(path, subcommandName)
			leafSubcmd = subcmd
			argIndex++

			// Move to nested subcommands if available
			if subcmd.Subcommands != nil {
				currentSubcommands = subcmd.Subcommands
			} else {
				// No more nested - this is the leaf
				break
			}
		}

		// Determine what we're completing
		partial := ""
		if pos-1 >= 0 && pos-1 < len(args) {
			partial = args[pos-1]
		}

		// If we're at a position where we could be completing a nested subcommand name
		if argIndex == remainingPos && leafSubcmd != nil && len(leafSubcmd.Subcommands) > 0 {
			// Check if completing a flag or a nested subcommand
			if strings.HasPrefix(partial, "-") || strings.HasPrefix(partial, "+") {
				// Complete flags for this level (root globals + current subcommand flags)
				tempCmd := &Command{
					name:       leafSubcmd.Name,
					flags:      append(cmd.rootGlobalFlags(), leafSubcmd.Flags...),
					separators: leafSubcmd.Separators,
				}
				return tempCmd.completeFlagNames(partial), nil
			}

			// Complete nested subcommand names
			return cmd.completeNestedSubcommandNames(leafSubcmd.Subcommands, partial), nil
		}

		// We have a leaf subcommand, complete its arguments
		if leafSubcmd != nil {
			// Create a temporary command for the leaf subcommand
			tempCmd := &Command{
				name:       leafSubcmd.Name,
				flags:      append(cmd.rootGlobalFlags(), leafSubcmd.Flags...),
				separators: leafSubcmd.Separators,
			}

			// Complete using subcommand context (remaining args after subcommand path)
			subcommandArgs := remaining[argIndex:]
			// subcommandPos needs +1 because analyzeCompletionContext expects COMP_WORDS-style
			// indexing where position 0 is the command name (in this case, the subcommand name)
			subcommandPos := remainingPos - argIndex + 1

			ctx := tempCmd.analyzeCompletionContext(subcommandArgs, subcommandPos)
			// Merge in already-parsed root globals
			for k, v := range rootGlobals {
				ctx.GlobalFlags[k] = v
			}

			return tempCmd.executeCompletion(ctx)
		}

		// Unknown subcommand at current level - show available subcommand names
		return cmd.completeNestedSubcommandNames(currentSubcommands, partial), nil
	}

	return []string{}, nil
}

// completeRootGlobalFlags generates completions for root global flags only
func (cmd *Command) completeRootGlobalFlags(partial string) []string {
	var matches []string
	partialLower := strings.ToLower(partial)

	for _, spec := range cmd.flags {
		if spec.Scope != ScopeGlobal || spec.Hidden {
			continue
		}

		for _, name := range spec.Names {
			nameLower := strings.ToLower(name)
			if partialLower == "" || partialLower == "-" || partialLower == "+" || strings.HasPrefix(nameLower, partialLower) {
				matches = append(matches, name)
			}

			// Add +flag version
			if strings.HasPrefix(name, "-") {
				plusVersion := "+" + name[1:]
				plusLower := strings.ToLower(plusVersion)
				if partialLower == "+" || strings.HasPrefix(plusLower, partialLower) {
					matches = append(matches, plusVersion)
				}
			}
		}
	}

	return matches
}

// completeSubcommandNames generates completions for subcommand names
func (cmd *Command) completeSubcommandNames(partial string) []string {
	var matches []string
	partialLower := strings.ToLower(partial)

	for name := range cmd.subcommands {
		nameLower := strings.ToLower(name)
		if partialLower == "" || strings.HasPrefix(nameLower, partialLower) {
			matches = append(matches, name)
		}
	}

	return matches
}

// completeNestedSubcommandNames generates completions for nested subcommand names
func (cmd *Command) completeNestedSubcommandNames(subcommands map[string]*Subcommand, partial string) []string {
	var matches []string
	partialLower := strings.ToLower(partial)

	for name := range subcommands {
		nameLower := strings.ToLower(name)
		if partialLower == "" || strings.HasPrefix(nameLower, partialLower) {
			matches = append(matches, name)
		}
	}

	return matches
}

// completeFlagNames generates completions for flag names (used by temporary commands)
func (cmd *Command) completeFlagNames(partial string) []string {
	var matches []string
	partialLower := strings.ToLower(partial)

	for _, spec := range cmd.flags {
		if spec.Hidden {
			continue
		}

		for _, name := range spec.Names {
			// Add -flag version
			nameLower := strings.ToLower(name)
			if partialLower == "" || partialLower == "-" || partialLower == "+" || strings.HasPrefix(nameLower, partialLower) {
				matches = append(matches, name)
			}

			// Add +flag version (convert -flag to +flag)
			if strings.HasPrefix(name, "-") {
				plusVersion := "+" + name[1:]
				plusLower := strings.ToLower(plusVersion)
				if partialLower == "+" || strings.HasPrefix(plusLower, partialLower) {
					matches = append(matches, plusVersion)
				}
			}
		}
	}

	// Add built-in flags
	builtins := []string{"-help", "--help", "-h", "-man", "-completion-script"}
	for _, builtin := range builtins {
		if partialLower == "" || partialLower == "-" || strings.HasPrefix(builtin, partialLower) {
			matches = append(matches, builtin)
		}
	}

	return matches
}
